# 분할 정복

## 분할 정복 뜻

- 분할: 현재 문제와 동일하되 입력의 크기를 더 작은 다수의 부분 문제로 분할한다. 

- 정복: 부분 문제를 재귀를 통해서 해결한다. 부분 문제의 크기가 충분히 작으면 직접 해결한다. 

- 결합: 부분 문제의 해를 결합해 원래 문제의 해가 되도록 만든다. 

- 분할 정복의 대표적인 예가 병합 정렬.

## Intro 

- 여기애서는 분할 정복 알고리즘들을 살펴본다.
  - 대표적으로는 최대 부분 배열 문제 (maximum-subarray problem) 을 푸는 것. 
    - 이 알고리즘은 배열을 입력받아서 가장 큰 합을 가지는 연속 부분 배열을 찾는 문제다.
  - n x n 행렬을 곱하는 두 가지 분할정복 알고리즘
    - 하나는 $\Theta(n^3)$시간에 수행되고 다른 하나는 스트라센 알고리즘 (Strassen's algorithm) 은 $O(n^2.81)$ 로 수행된다.

## 점화식 

- 분할정복 알고리즘은 점화식을 통해서 계산할 수 있다. 
  - **(똑같은 문제이고, 입력이 작아지고 몇 개의 추가 부분 문제가 생기고 결합과 분할 비용을 생각해보면 점화식과 같다.)** 
  - 점화식은 더 작은 입력에 대한 자신의 값으로 표현한 방정식 또는 부정식이다. 
  - 병합정렬은 $T(n) = 2T(n/2) + \Theta(n) if (n > 1)$ 이렇게 표현이 가능하다. 
- 점화식을 푸는 방법은 세 가지가 있다.
  - 치환법 (substitution method)
    - 한계를 추측하고 그 한계가 맞는지 증명하는 방법으로 수학적 귀납법을 이용한다. 
  - 재귀 트리 방법 (recursion tree method)
    - 점화식을 각 노드의 재귀 호출의 해당 레벨에 따른 비용을 나타내도록 트리로 변환해서 점화식을 풀고 이 합계를 구해서 계산한다.
  - 마스터 방법 (master method)
    - 다음과 같은 형식의 점화식을 답으로 제시해준다. 
    - $T(n) = aT(n/b) + f(n)$
      - 이 식은 분할 정복이 a 개의 부분 문제가 생겨나고 입력은 1/b 배가 된다. 그리고 결합과 분할 비용에서 f(n) 이 생긴다.
    - 마스터 방법은 세 가지 경우에 대해서 암기가 필요하다.
  - 때로는 $T(n) <= 2T(n/2) + \Theta(n)$ 과 같은 문제를 만나게 되는데 이 경우에는 상한만 계산하면 된다. 그러므로 해를 표현할 땐 $O$ 를 이용해서 표현하면 된다. 
    - **방정식의 경우에서는 $\Theta(n)$ 로 표현하겠네**

## 점화식에서 고려사항 

- 입력 n 이 홀수인지, 짝수인지 그런 것에 대해서 고민하지 않는다. 
- 충분히 작은 상수에 대해서 고민하지 않는다. 예로 n 이 1보다 클 경우, 1일 경우 이렇게 나누지 않는다. n 이 1 일 경우는 그냥 무시한다. 
- 내림, 올림, 한계 조건들은 일단은 무시하고 계산하고 이후에 계산이 된 후 고려해본다. 

## 최대 부분 배열 문제 

### 간단한 문제 소개

- 주식을 사서 판다고 했을 때 가장 크게 이득을 얻는 방법
- 날짜별 주가는 다 안다고 가정함.

````text
날짜: 0   1   2   3   4   5   6   7   8   9   10

가격: 100 113 110 85  105 102 86  63  81  101 94
````


### Thinking 

- 가장 나이브한 생각부터
  - 가장 싸게 사서 가장 비싸게 파는게 가능한가? 
  - `안됨. 가장 비싼날이 가장 싼 날보다 앞에 있을 수 있으므로.`
- 내가 돈을 번다는 건 가격의 변동 떄문에 번다. 
  - 순차적인 가격 변동의 합이 최대가 되는 게 내가 최대로 돈을 많이 버는 법이다. (문제가 바꼈다. 가격 변동의 조합으로.)
  - 근데 이 변동의 조합은 직접 계산할 수 밖에 없겠는데? 어떠한 규칙이 있는게 아니기 때문에.
  - 즉 `계산을 할 수 밖에 없는 문제라고 판단했다.` 
    - 모든 구간을 다 찾아봐야함.
- 어떻게 가격 변동의 조합을 모두 따져 볼 것이냐. 
  - 가장 나이브한 방법은 $\Theta(n^2)$ 임. 최대값 계산하면서.
  - 문제를 쪼갤 수 있으니 분할 정복도 가능할 거 같다. 분할 정복을 이용하면 탐색구간이 나뉜다.
    - 부분 배열 A[low..mid] 에 완전히 포함되는 경우
    - 부분 배열 A[mid + 1..high] 에 완전히 포함되는 경우
    - 중간값에 걸쳐서 있는 경우.
- **내가 생각한 알고리즘이 맞다는 증거는 어떻게 증명할 수 있을까**
  - 분할 정복은 큰 문제와 작은 문제가 동일해야한다. 

## 분할정복 알고리즘 분석하기 

- 분할정복의 경우 점화식으로 생각해볼 수 있다. 
- $T(n)$ 이 FIND-MAXIMUM-SUBARRAY 라고 생각해보면 분할될 때마다 2개의 부분문제와 1/2로 입력이 줄어든다는 걸 알 수 있다. 그리고 중간값에 걸쳐서 존재하는 경우의 시간 복잡도는 $Theta(n)$ 이다. 
  - 그러므로 $T(n) = 2*T(n/2) + \Theta(n)$ 으로 표현될 것.
  - 이를 이후에 알아볼 Master Method 를 적용해보면 $T(n) = \Theta(nlgn)$ 임을 알 수 있다. 
  - Master Method 를 쓰지 않고 재귀 트리로도 증명이 가능함.
    - T(n) 의 depth 는 logN 일 것. 그리고 매 depth 마다 N 개가 존재. 그래서 곱하면 됨.
    
    
## 행렬 곱셈을 위한 스트라센 알고리즘 

- 행렬 곱셈의 식은 다들 알 것. 

프로시저로 설명하자면 다음과 같다. 

```text
SQUARE-MATRIX-MULTIPLY (A, B 행렬) A 와 B 는 n x n 행렬이라고 가정. 

n = A.rows 
C 는 새로운 n x n 행렬이라고하자. 
for i = 1 to n 
    for j = 1 to n 
        c(ij) = 0 
        for k = 1 to n 
            c(ij) = c(ij) + a(ik) * b(kj) 
```  

- 그래서 행렬의 곱이 $omega(n^3)$ 이 걸린다고 생각할 수 있지만 $O(n^3)$ 안에 끝낼 수 있다. 스트라센 알고리즘을 쓰면.

## 스트라센 유도   

- 여기서는 전체의 행렬 곱셈을 n/2 x n/2 로 쪼개서 계산하는 방법으로 분할 정복한다.
  - (이렇게 잘 쪼개기 위해서 n 을 2의 거듭제곱이라고 가정하기도 한다. 알고리즘에서 이렇게 취해도 되니까.)
```text
A = [
    A(11), A(12)
    A(21), A(22)
]

B = [
    B(11), B(12)
    B(21), B(22)
]

C = [
    C(11), C(12)
    C(21), C(22)
]
``` 
  - C(11) = A(11) * B(11) + A(12) * B(21)
  - C(12) = A(11) * B(12) + A(12) * B(22)
  - C(21) = A(21) * B(11) + A(22) * B(21) 
  - C(22) = A(21) * B(12) + A(22) * B(22)
  - 이렇게 하면 총 8번의 행렬 곱셈이 필요하다. 근데 스트라센으로 쓰면 10개의 정해진 행렬합을 정해놓고, 이를 이용해서 7 개의 행렬곱을 만들기만 하면 행렬식을 계산할 수 있다고 한다.
  - 그래서 원래 식은 $T(n) = 8 * T(n/2) + \Theta(n^2)$ 인데 이를 스트라센으로 풀면 $T(n) = 7 * T(n/2) + \Theta(n^2)$ 로 가능. 
  - 행렬합 자체는 $\Theta(n^2)$ 가 걸림 행렬요소가 n/2 이니, 이거 제곱하면 된다.   
  
  
## 점화식을 풀기 위한 치환법 

- 점화식을 푸는 방법 중 하나. 적용하는 방법은 간단하다. 
  - 해의 모양을 추측 떄린다. 그리고 귀납법을 이용해서 증명한다. 
  - 추측을 때리는 것이기 때문에 상한이나 하한을 결정하는데 유용한 듯.
- 예시로 $T(n) = 2 * T(n/2) + n$ 식이 있다고 가정해보자. 
  - $T(n) = O(n)$ 이라고 가정해보자. (실제 식은 $T(n) = O(nlgn)$ 임.)
  - 그러면 $2* T(n/2) + n <= n$ 이 된다. 이건 $2n <= n$ 이라는 식이 되서 모순임. 
  - 올바른 가정으로 $T(n) = O(nlgn)$ 이나 $T(n) = O(n^2)$ 라고 가정하면 만족할거임.
- 이렇게 귀납법을 쓸 떄 한계 조건에 대해서도 성립하는지 확인해봐야한다. 
  - 예로 $T(1) = 1$ 이라는 조건이 있으면 이런것도 성립하는지 봐야한다. 
  - 이게 어려우면 `점근적 정의` 를 이용해서 정의하는 방법도 있다. $n >= n0 에 대해서 T(n) <= cnlgn$ 임을 증명한다던지. 아니면 $n >= 3$ 인 경우에 대해서만 정의한다던지
- 여기서 추측을 잘하는 방법으로는 여유롭게 상한과 하한을 잡아놓고 줄여나가보라고 한다.

### 치환법의 미묘한 사항 

- 귀납법으로 증명할려고 해도 세부 사항 떄문에 증명되지 않을 수 있다.
  - 예시로 $T(n) = 2 * T(n/2) + 1$ 과 같다고 해보자. 이걸 $T(n) = O(n)$ 으로 가정해보면 귀납법으론 안됨. (근데 실제론 맞음.)
    - 안되는 이유는 $n + 1 <= n$ 이라는 식이 최종적으로 만들어지기 떄문에. 
- 이렇게 안될 때는 저차항을 무시해보면 된다. (여기서는 1을 무시하면 되고, 추측을 저차항까지 고려해서 설계해보는 것으로 증명한다. 예시로 $T(n) <= 3n-d$ 로 증명해본다던가.

### 치환법의 변수 바꾸기 

- 대수적 조작을 통해서 더 간단하게 치환법을 적용할 수 있음. 
  - $T(n) = 2 * T(\sqrt(n)) + \log(n)$ 이 있다면 $m = lgn$ 으로 가정해보는 것. 
  - 그러면 $T(2^m) = 2 * T(2^(m/2)) + m 이 된다. 여기서 S(M) = T(2^m) 으로 가정해보자. 그러면 S(M/2) = T(2^(M/2)) 임
  - 그래서 정리해보면 $S(M) = 2 * S(M/2) + M$ 으로 됨.   (M 이 m 보다 더 크니까 이렇게 잡아도 상관없을듯.)

## 점화식을 풀기 위한 재귀 트리 방법 

- 치환식을 통해서 추측하는게 어려울 수도 있다.
- 그래서 이 경우에는 재귀 트리를 만들어가면서 수평과 수직 레벨을 계산하고 이를 식으로 표현함으로써 추측을 해볼 수 있다. 
  - 물론 계산을 잘한다면 재귀 트리로 증명하는 것도 가능하다. 
- 에를 들어서 $T(n) = 3T(n/4) + \Theta(n^2)$ 이 있다고 가정해보자. 
  - 그리고 이걸 재귀 트리로 만들어나가면 이렇게 식이 표현될 것. $cn^2 + 3/16 cn^2 + (3/16)^2 cn^2 + ... \Theta(n^{\log_4 3})$ 
  - 입력은 1/4 씩 줄어듦으로 레벨은 $level = \log_4 n$ 이 될 것. 레벨을 알면 식이 얼마나 진행되는 지 알 수 있다. 
  - 정리하자면 다음과 같은 수식으로 된다.$\sum_{i=0}^{\log_4 n-1}{(3/16)^i cn^2} + \Theta(n^{\log_4 3})$  