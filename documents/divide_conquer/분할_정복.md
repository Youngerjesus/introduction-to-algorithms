# 분할 정복

## 분할 정복 뜻

- 분할: 현재 문제와 동일하되 입력의 크기를 더 작은 다수의 부분 문제로 분할한다. 

- 정복: 부분 문제를 재귀를 통해서 해결한다. 부분 문제의 크기가 충분히 작으면 직접 해결한다. 

- 결합: 부분 문제의 해를 결합해 원래 문제의 해가 되도록 만든다. 

- 분할 정복의 대표적인 예가 병합 정렬.

## Intro 

- 여기애서는 분할 정복 알고리즘들을 살펴본다.
  - 대표적으로는 최대 부분 배열 문제 (maximum-subarray problem) 을 푸는 것. 
    - 이 알고리즘은 배열을 입력받아서 가장 큰 합을 가지는 연속 부분 배열을 찾는 문제다.
  - n x n 행렬을 곱하는 두 가지 분할정복 알고리즘
    - 하나는 $\Theta(n^3)$시간에 수행되고 다른 하나는 스트라센 알고리즘 (Strassen's algorithm) 은 $O(n^2.81)$ 로 수행된다.

## 점화식 

- 분할정복 알고리즘은 점화식을 통해서 계산할 수 있다. 
  - **(똑같은 문제이고, 입력이 작아지고 몇 개의 추가 부분 문제가 생기고 결합과 분할 비용을 생각해보면 점화식과 같다.)** 
  - 점화식은 더 작은 입력에 대한 자신의 값으로 표현한 방정식 또는 부정식이다. 
  - 병합정렬은 $T(n) = 2T(n/2) + \Theta(n) if (n > 1)$ 이렇게 표현이 가능하다. 
- 점화식을 푸는 방법은 세 가지가 있다.
  - 치환법 (substitution method)
    - 한계를 추측하고 그 한계가 맞는지 증명하는 방법으로 수학적 귀납법을 이용한다. 
  - 재귀 트리 방법 (recursion tree method)
    - 점화식을 각 노드의 재귀 호출의 해당 레벨에 따른 비용을 나타내도록 트리로 변환해서 점화식을 풀고 이 합계를 구해서 계산한다.
  - 마스터 방법 (master method)
    - 다음과 같은 형식의 점화식을 답으로 제시해준다. 
    - $T(n) = aT(n/b) + f(n)$
      - 이 식은 분할 정복이 a 개의 부분 문제가 생겨나고 입력은 1/b 배가 된다. 그리고 결합과 분할 비용에서 f(n) 이 생긴다.
    - 마스터 방법은 세 가지 경우에 대해서 암기가 필요하다.
  - 때로는 $T(n) <= 2T(n/2) + \Theta(n)$ 과 같은 문제를 만나게 되는데 이 경우에는 상한만 계산하면 된다. 그러므로 해를 표현할 땐 $O$ 를 이용해서 표현하면 된다. 
    - **방정식의 경우에서는 $\Theta(n)$ 로 표현하겠네**

## 점화식에서 고려사항 

- 입력 n 이 홀수인지, 짝수인지 그런 것에 대해서 고민하지 않는다. 
- 충분히 작은 상수에 대해서 고민하지 않는다. 예로 n 이 1보다 클 경우, 1일 경우 이렇게 나누지 않는다. n 이 1 일 경우는 그냥 무시한다. 
- 내림, 올림, 한계 조건들은 일단은 무시하고 계산하고 이후에 계산이 된 후 고려해본다. 

## 최대 부분 배열 문제 

### 간단한 문제 소개

- 주식을 사서 판다고 했을 때 가장 크게 이득을 얻는 방법
- 날짜별 주가는 다 안다고 가정함.

````text
날짜: 0   1   2   3   4   5   6   7   8   9   10

가격: 100 113 110 85  105 102 86  63  81  101 94
````


### Thinking 

- 가장 나이브한 생각부터
  - 가장 싸게 사서 가장 비싸게 파는게 가능한가? 
  - `안됨. 가장 비싼날이 가장 싼 날보다 앞에 있을 수 있으므로.`
- 내가 돈을 번다는 건 가격의 변동 떄문에 번다. 
  - 순차적인 가격 변동의 합이 최대가 되는 게 내가 최대로 돈을 많이 버는 법이다. (문제가 바꼈다. 가격 변동의 조합으로.)
  - 근데 이 변동의 조합은 직접 계산할 수 밖에 없겠는데? 어떠한 규칙이 있는게 아니기 때문에.
  - 즉 `계산을 할 수 밖에 없는 문제라고 판단했다.` 
    - 모든 구간을 다 찾아봐야함.
- 어떻게 가격 변동의 조합을 모두 따져 볼 것이냐. 
  - 가장 나이브한 방법은 $Theta(n^2)$ 임. 최대값 계산하면서.
  - 문제를 쪼갤 수 있으니 분할 정복도 가능할 거 같다. 분할 정복을 이용하면 탐색구간이 나뉜다.
    - 부분 배열 A[low..mid] 에 완전히 포함되는 경우
    - 부분 배열 A[mid + 1..high] 에 완전히 포함되는 경우
    - 중간값에 걸쳐서 있는 경우.
- **내가 생각한 알고리즘이 맞다는 증거는 어떻게 증명할 수 있을까**
  - 분할 정복은 큰 문제와 작은 문제가 동일해야한다. 

